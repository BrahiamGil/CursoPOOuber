COMANDOS B√ÅSICOS
git init: crear un repositorio.
git add: agregar un archivo a staging.
git commit -m ‚Äúmensaje‚Äù: guardar el archivo en git con un mensaje.
git branch : crear una nueva rama.
git checkout: moverse entre ramas.
git push: mandar cambios a un servidor remoto.
git fetch: traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local.
git merge: tiene dos usos. Uno es la fusi√≥n de ramas, funcionando como un commit en la rama actual, trayendose la rama indicada. El otro uso es guardar los cambios de un servidor remoto en nuestro directorio.
git pull: fetch y merge al mismo tiempo.

COMANDOS PARA VOLVER O CORREGIR
git checkout ‚Äúcodigo de version‚Äù ‚Äúnombre del archivo‚Äù: volver a la ultima version commiteada.
git reset: vuelve al pasado sin posibilidad de volver al futuro, se debe usar con especificaciones.
git reset --soft vuelve a la versi√≥n en el repositorio pero guarda los cambios en staging, as√≠ podemos aplicar actualizaciones a un nuevo commit.
git reset --hard TODO VUELVE A LA VERSI√ìN ANTERIOR
git reset HEAD saca los cambios de staging pero no los borra, es lo opuesto a git add.
git rm: elimina los archivos pero no su historial, si queremos recuperar algo solo hay que regresar, se usa as√≠:
git rm --cached elimina los archivos en staging pero los mantiene en el disco duro.
git rm --force elimina los archivos de git y del disco duro.

COMANDO PARA REVISAR Y COMPARAR
git status: estado de archivos en el repositorio.
git log: historia entera del archivo.
git log --stat: cambios espec√≠ficos en el archivo a partir de un commit.
git show: cambios hist√≥ricos y espec√≠ficos hechos en un archivo.
git diff ‚Äúcodigo de version 1‚Äù ‚Äúcodigo de version 2‚Äù: comparar cambios entre versiones.
git diff: comparar directorio con staging.

COMANDOS GIT

- git init: Crea un nuevo repositorio Git.
- git clone: Crea una copia de un repositorio remoto en tu m√°quina local.
- git add: Agrega cambios a un archivo o archivos para ser incluidos en el siguiente commit.
- git commit: Crea un nuevo commit con los cambios agregados previamente.
- git status: Muestra el estado actual del repositorio, incluyendo los archivos modificados, agregados o eliminados.
- git diff: Muestra las diferencias entre los cambios realizados en los archivos desde el √∫ltimo commit.
- git pull: Obtiene los cambios m√°s recientes desde un repositorio remoto y los fusiona con la rama actual.
- git push: Sube los cambios locales a un repositorio remoto.
- git branch: Muestra las ramas disponibles y permite crear, eliminar o cambiar entre ellas.
- git checkout: Cambia entre ramas o versiones de un archivo espec√≠fico.
- git merge: Fusiona cambios de dos o m√°s ramas.
- git remote: Muestra los repositorios remotos gconectados a tu repositorio local.
- git log: Muestra un registro de los commits realizados en el repositorio.
- git tag: Crea, lista o elimina etiquetas en el repositorio.
- git reset: Permite deshacer cambios en un archivo o un commit espec√≠fico.
- git stash: Guarda temporalmente los cambios sin realizar un commit completo.
- git rebase: Permite modificar la historia de un repositorio cambiando el orden o los detalles de los commits.
- git config: Configura opciones de Git, como nombre de usuario, correo electr√≥nico o alias de comandos.
- git rm: Elimina archivos del repositorio y del sistema de archivos local.
- git rm --cached: Elimina los archivos del √°rea de Staging y del pr√≥ximo commit pero los mantiene en nuestro disco duro.
- git rm --force: Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder
- git show ‚Äúnombre del archivo‚Äù = Nos permite poder mirar la ultima modificacion que se la ha realizado al archivo
- git rm --cached ‚Äúnobre del archivo‚Äù = Nos permite remover el archivo de la ubicacion en memoria en la que

El flujo general de Gitflow es el siguiente:

Se crea una rama develop a partir de main.
Se crea una rama release a partir de la develop.
Se crean ramas feature a partir de la develop.
Cuando se termina una rama feature, se fusiona en la rama develop.
Cuando la rama release est√° lista, se fusiona en las ramas develop y main.
Si se detecta un problema en main, se crea una rama hotfix a partir de main.
Una vez terminada la rama hotfix, esta se fusiona tanto en develop como en main.

Terminal linux

mkdir miDirectorio: es para crear un directorio
touch miArchivo: es para crear archivo desde la terminal
cp file1 file_bk: es para copiar un archivo
mv file_bk .. : es para mover atr√°s el archivo
mv file_bk fileCopy: es para renombrar el archivos
rm -i filecopy: sirve para borrar el archivo
rm -ri miDirectorio: es para eliminar directorios con archivos
head principios_de_usabilidad.md: nos va mostrar las primeras 10 lineas de un archivo de texto
tail principios_de_usabilidad.md: nos va mostrar las ultimas 10 lineas
less principios_de_usabilidad.md: es un comando mas avanzado que nos deja hasta buscar
open principios_de_usabilidad.md: para abrir un archivo
xdg-open principios_de_usabilidad.md: para abrir con linux
nautilus Documentos/Dev: sirve para abrir carpetas
alias l="ls -lh": es para crear un alias
help cd:es para pedir ayuda
man cd: es el manual de usuario de un comando
info cd: es igual a un manual solo mas resumida
whatis cd: es un comando para pedir ayuda pero mas corto
ls *.txt: nos muestra todo los archivos txt
ls datos*: nos encuntra todo los nombres que coloquemos antes del asterisco
ls datos?: solo encontra al que tenga el mismo nombre pero solo con un caracter despues
ls datos???: encuentra los que tenga 3 caracteres
ls *.html: va encontrar todo los archivos que sean html
ls [[:upper:]]*: este sirve para mostrar carpetas o archivos que inicien por mayusculas y termine con minuscula o mayuscula
ls -d [[:upper:]]*:para solo buscar las carpetas que inicie con mayuscula
ls -d [[:lowe:]]*: para encontrar las que empiezan por minuscula
ls [ad]*: agregando cualquier palabra nos buscara toda carpeta similar
*	Busca todo
?	Busca por cantidad de caracteres
[]	Busca por caracteres espec√≠ficos
echo "Hola platzi": imprime
cat error.txt: sirve para contatenar los archivos
ls -lh | less:
ls -lh | tee output.txt | less
cowsay "Hola amigos": nos muestra una vaca con el texto
-Comandos separados por punto y coma ‚Äú;‚Äù : Se ejecutan uno seguido del otro en el orden en que fueron puesto.
Uno no se ejecuta hasta que el otro proceso aya terminado.
-Comandos separados por & : Se ejecutan todos al mismo tiempo,
es decir de forma as√≠ncrona.
-Comandos separados por && : Se ejecutan solo si el comando anterior se aya ejecutado exitosamente.
Suponemos que A, B y C son comando:
A && B && C El B solo se va ejecutar si el A se ejecuta exitosamente,
y el C solo se va ejecutar si el B si ejecuta exitosamente. Si el B no se ejecuta exitosamenta el C no se ejecuta. Si el A no se ejecuta exitomante el B y el C no se ejecutan.
-Comandos separados por || : Solo se ejecuta uno. Sea cuantos comandos tienes separados por || solo ejecuta o toma en cuenta el primer que se ejecuta exitosamente (bajo la redundacia), y descarta automaticamente los demas. Cuando uno de los comandos se ejecuta exitosamente, descarta los demas comandos.

Tipos de archivos
- Un archivo normal
d Un directorio
l Un link simbolico
b Un archivo de bloqueo especial. Son archivos que manejan la informacion de los bloqueos de datos como una usb

Tipo de modo
Due√±o - rwx - 1 1 1 = 7
Grupo - r-x - 1 0 1 = 5
World - r-x - 1 0 1 = 5

Mod simb√≥lico
u: Solo para el usuario
g Solo para el grupo
o: Solo para otros (es el world).
a: Aplica para todos
su root: en windows es sudo su

ln -s: Hace referencia a un lugar
printenv: nos lleva a todas las variables de entorno que tenemos configuradas
echo $Home: para imprimir donde esta la variable de entorno
echo $PATH, os muestra donde esta
code .bashrc: para abrir el visual
which code: nos sirve para bucar donde esta
find ./ -name file :nos ayuda a buscar un archivo
find./ -name *.txt|
find ./ -type f: o d para buscar directorios buscarlo por tipos
find ./ -type f -name *.log
find ./ -size 20M: va buscar archivos por sus peso

grep: sirve para encontar coincidencia
wc movies.csv: sirve para contar cuantas palabras hay

utilidades de la red
ifconfig: nos muestra informacion de nuestra red
ping www.google.com : nos muestra si una pagina esta activa
curl www.google.com:nos trae un archivo
wget www.google.com: Trae desde internet y lo guarda
traceroute www.google.com: nos dice por todas la computadoras que vamos a pasar cuando vamos a entrar
netstat -i: nos muestra los dispositivos de red
tar -cvf Tocompress.tar ToCompress: Sirve para comprimir archivos
tar -cvzf ToCompress.tar.gz ToCompress: Sirve para comprimir y es mas eficiente
tar -xzvf Tocompress.tar: para descomprimir archivo zip
apt : para ver bibliotecas
zip -r ToCompressInZip.zip ToCompress: descomprimit
unzip TocompressInZip.zip: para descomprimir
ps: para mirar que proceso estan corriendo
kill 267: para que no siga corriendo
top: nos muestra cual de los procedimientos nos esta cosumiendo mas

Procesos en foreground y background
¬øC√≥mo manejar procesos?
Diferencia entre Ctrl + C y Ctrl + Z
Ctrl + C Lo que hace es que finaliza o mata un proceso.
Ctrl + Z Lo que hace es que pausa o suspende un proceso con lo que despu√©s lo podremos volver a llamar con el comando fg foreground (primer plano)
o con el comando bg background (segundo plano)
Y un ejemplo muy sencillo que les servir√° para controlar procesos es el siguiente:
.
Crear un listado recursivo (Que liste todos los archivos y directorios)
Para eso seguimos los sigueintes pasos:
1.- Primero hacemos el comando cd / para dirigirnos a la ra√≠z de nuestro sistema.
2.- Despu√©s ejecutamos el comando ls -R y comenzar√° a listar TODO lo que existe dentro de nuestro S.O.
3.- Ahora lo que hacermos ser√° confirmar lo aprendido, utilizamos Ctrl + C y veremos que se cancela el proceso,
ero lo interesante viene cuando hacemos lo siguiente üòÑ
4.- Ahora ejecutamos el mismo comando para listar TODO, ls -R y lo detenemos con Ctrl + Z a lo que nos saldr√° lo siguiente: [N√∫mero del proceso]
 + Id del proceso + En donde se detuvo el proceso
Y se ver√° algo como esto: [1] + 40751 suspended (signal) ls --color=tty -R
Y repetiremos el paso 4 otras 3 veces (Ustedes conf√≠en üòÑ)
Ahora si ejecutamos el comando jobs nos mostrar√° todos los procesos suspendidos y si tenemos ejecutando alguno en segundo plano.
Imgur
Para volver a activar alg√∫n proceso podemos hacerlo con el comando fg %N√∫mero del proceso
Por ejemplo en bash con fg %1 y en zsh con fg %1 para volver a correr el primer proceso que suspendimos, y ahora le damos Crl + C para ahora
s√≠ matarlo, ahora el proceso 1 ya no existir√° al ejecutar jobs pero el 2, 3 y 4 ah√≠ seguir√°n üòÑ
Esto es muy importante para cuando queremos manejar diferentes procesos, por ejemplo con el comando sleep 10000 & podr√° un proceso en segundo plano,
entonces no lo podremos ver, pero nos marca el N√∫mero del proceso entre los [] tambi√©n lo podemos ver con jobs junto con su n√∫mero de proceso,
si lo queremos traer a primer plano lo podemos hacer con el comando fg %1 por ejemplo y de ah√≠ ya cancelarlo o suspenderlo, o una manera m√°s r√°pida,
solo ejecutar el comando kill %N√∫mero del proceso por ejemplo: con el mismo ejemplo de sleep 10000 & si nos da el [1] lo podremos terminar con kill
1 o kill %1 y nos saldr√° algo como [1] + 41723 terminated sleep 10000 y ahora ya saber como manejar y exterminar todos los procesos
como terminator ü§ñ
.
.
Diferencia entre Ctrl + L y clear
Ctrl + L Lo que hace es que manda para arriba lo que est√° impreso en la terminal, dej√°ndola a simple vista limpia, pero en realidad lo puedes
regresar a eso que esta impreso ah√≠.
clear Lo que hace es que limpia la terminal, y todo lo que estaba impreso en la terminal.

Editore de texto en la terminal
hay dos terminales para escribir en la terminal que son vim vi
para salir de all√≠ hay que darle :q
sudo apt install tilix

Orientacion a objetos: POO
Paradigma: Es la teor√≠a que suministra la base y modelo para resolver problemas

UML

Estos son los niveles de visibilidad que puedes tener:

- private
+ public
# protected
~ default

Asociaci√≥n
Como su nombre lo dice, notar√°s que cada vez que est√© referenciada este tipo
de flecha significar√° que ese elemento contiene al otro en su definici√≥n.
La flecha apuntar√° hacia la dependencia.
Con esto vemos que la ClaseA est√° asociada y depende de la ClaseB.

Herencia
Siempre que veamos este tipo de flecha se estar√° expresando la herencia.
La direcci√≥n de la flecha ir√° desde el hijo hasta el padre.
Con esto vemos que la ClaseB hereda de la ClaseA

Agregaci√≥n

Este se parece a la asociaci√≥n en que un elemento depender√° del otro, pero en este caso ser√°:
Un elemento depender√° de muchos otros. Aqu√≠ tomamos como referencia la multiplicidad del elemento.
Lo que com√∫nmente conocer√≠as en Bases de Datos como Relaciones uno a muchos.
Con esto decimos que la ClaseA contiene varios elementos de la ClaseB.
Estos √∫ltimos son com√∫nmente representados con listas o colecciones de datos

Composici√≥n
Este es similar al anterior solo que su relaci√≥n es totalmente compenetrada de tal modo que conceptualmente una de estas
clases no podr√≠a vivir si no existiera la otra.
Con esto terminamos nuestro primer m√≥dulo. Vamos al siguiente para entender c√≥mo podemos hacer
 un an√°lisis y utilizar estos elementos para construir nuestro diagrama de clases de Uber.